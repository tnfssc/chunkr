use crate::{
    // models::workers::table_ocr::{TableStructure, TableStructureResponse},
    utils::configs::extraction_config::Config,
};
use base64::{engine::general_purpose, Engine as _};
// use reqwest::multipart;
use serde_json::{json, Value};
use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::Path;
pub async fn call_llm(file_path: &Path, prompt: String) -> Result<String, Box<dyn Error>> {
    let config = Config::from_env().unwrap();
    let url = config.ocr_llm_url;
    let key = config.ocr_llm_key;
    let model = config.ocr_llm_model;
    let client = reqwest::Client::new();

    // Read the image file and encode it to base64
    let mut file = File::open(file_path)?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer)?;
    let base64_image = general_purpose::STANDARD.encode(&buffer);

    // Construct the request payload
    let payload = json!({
        "model": model,
        "messages": [
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": prompt
                    },
                    {
                        "type": "image_url",
                        "image_url": {
                            "url": format!("data:image/jpeg;base64,{}", base64_image)
                        }
                    }
                ]
            }
        ],
        "max_tokens": 8000,
        "temperature": 0.0  // Added temperature parameter set to 0 for deterministic output
    });

    // Send the request to the LLM API
    let response = client
        .post(format!("{}/v1/chat/completions", url))
        .header("Content-Type", "application/json")
        .header("Authorization", format!("Bearer {}", key))
        .json(&payload)
        .send()
        .await?;

    // Parse the response
    let response_body: Value = response.json().await?;
    println!("Response body: {}", response_body);
    let completion = response_body["choices"][0]["message"]["content"]
        .as_str()
        .unwrap_or("No response")
        .to_string();

    Ok(completion)
}

#[cfg(test)]
mod tests {
    use super::*;
    use futures::future::join_all;
    use std::path::Path;
    use std::time::Instant;
    use tokio;

    #[tokio::test]
    async fn test_ocr_llm() -> Result<(), Box<dyn std::error::Error>> {
        println!("Starting test_ocr_llm_with_image");

        let input_path = Path::new("input/test.jpg");
        println!("Using test image: {:?}", input_path);

        let prompt = "Task: Convert the provided image into a complete and precise HTML representation using advanced HTML techniques. DO NOT SIMPLIFY THE TABLE STRUCTURE AND ENSURE YOU COMPLETE THE ENTIRE TABLE. Get all content including titles, headers and footers.

        Instructions:
        1. Analyze the table thoroughly, ensuring no detail is overlooked.
        2. Create an HTML structure that exactly mirrors the layout and content of the table, using advanced HTML5 elements where appropriate (e.g., <thead>, <tbody>, <tfoot>, <colgroup>, <caption>).
        3. Include ALL text, numbers, and any other content present in the table.
        4. Preserve the table structure exactly as it appears, using appropriate HTML tags (<table>, <tr>, <td>, <th>, etc.).
        5. Maintain proper formatting, including any bold, italic, or other text styles visible. 
        6. Transcribe the content exactly as it appears, using appropriate semantic HTML elements (e.g., <strong>, <em>, <sup>, <sub>) where necessary.
        7. If applicable, use the <colgroup> and <col> elements to define column properties.
        8. Implement proper accessibility features, such as using 'scope' attributes for header cells and including a <caption> for the table if a title is present.
        9. PRESERVE ALL COMPLEXITY OF THE ORIGINAL TABLE IN YOUR HTML, including any nested tables, rowspans, or colspans.
        10. If the table contains any interactive elements or complex layouts, consider using appropriate ARIA attributes to enhance accessibility.
        11. ENSURE YOU COMPLETE THE ENTIRE TABLE. Do not stop until you have transcribed every single row and column.
        12. Double-check that you have included all rows and columns before finishing.
        
        Output: Provide the complete HTML code, without any explanations or comments. 
        Your response will be evaluated based on its completeness, accuracy, and use of advanced HTML techniques in representing every aspect of the table.
        It is crucial to maintain the exact structure and visual appearance of the input table and all its complexity - do not simplify or alter the table structure in any way.
        YOU MUST COMPLETE THE ENTIRE TABLE, INCLUDING ALL ROWS AND COLUMNS. Failure to do so will result in an incorrect response.
        
        IMPORTANT: If you find yourself running out of space, prioritize completing all the data in the table over maintaining perfect formatting. It's better to have all the data in a slightly less formatted table than to have an incomplete table.";
        let num_requests = 5;
        let start_time = Instant::now();

        let futures: Vec<_> = (0..num_requests)
            .map(|_| call_llm(input_path, prompt.to_string()))
            .collect();

        let results = join_all(futures).await;

        let total_duration = start_time.elapsed();
        let avg_duration = total_duration / num_requests as u32;

        println!(
            "Total time for {} requests: {:?}",
            num_requests, total_duration
        );
        println!("Average time per request: {:?}", avg_duration);

        let successful_results: Vec<_> = results.into_iter().filter_map(Result::ok).collect();

        // Save all responses to a single file with formatting
        let output_dir = Path::new("output");
        std::fs::create_dir_all(output_dir)?;
        let output_file = output_dir.join("all_llm_responses.txt");
        let mut output_content = String::new();

        for (index, response) in successful_results.iter().enumerate() {
            output_content.push_str(&format!("Response #{}\n", index + 1));
            output_content.push_str("=".repeat(20).as_str());
            output_content.push_str("\n");
            output_content.push_str(response);
            output_content.push_str("\n\n");
            output_content.push_str("=".repeat(40).as_str());
            output_content.push_str("\n\n");
        }

        std::fs::write(output_file, output_content)?;
        println!("All LLM responses saved to output/all_llm_responses.txt");

        assert!(
            !successful_results.is_empty(),
            "At least one LLM response should be successful"
        );
        assert_eq!(
            successful_results.len(),
            num_requests,
            "All requests should be successful"
        );

        println!("test_ocr_llm_with_image completed successfully");
        Ok(())
    }
}